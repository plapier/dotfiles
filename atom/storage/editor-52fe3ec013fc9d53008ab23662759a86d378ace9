{"mode":"editor","version":1,"windowDimensions":{"x":0,"y":23,"width":1440,"height":873,"maximized":false},"grammars":{"deserializer":"GrammarRegistry","grammarOverridesByPath":{}},"project":{"paths":["/Users/lapier/Sites/streams-ui/public/assets/js/modules/clean/react/streams"],"buffers":[{"text":"# THIS FILE SHOULD ONLY BE USED FOR THE STREAMS PROTOTYPE\n# AND IS NOT PRODUCTION-READY.\n#\n# CONTACT: elliott@dropbox.com or jeandenis@dropbox.com if you have any questions\n#\n# This view shows a single Stream activity in a stream of activities.\n\ndefine [\n  'external/react',\n  'jquery',\n  'modules/clean/viewer',\n  'modules/clean/react/streams/like_link',\n  'modules/clean/react/streams/autoResizingTextField',\n  'modules/clean/react/streams/loadingSpinner',\n  'modules/clean/react/streams/streamsUtil',\n  'modules/clean/react/streams/streamsViewer',\n  'modules/clean/react/streams/truncatedTextView',\n], (\n  React,\n  $j,\n  Viewer,\n  LikeLink,\n  AutoResizingTextField\n  LoadingSpinner\n  StreamsUtil\n  StreamsViewer\n  TruncatedTextView\n) ->\n\n  d = React.DOM\n  viewer = StreamsViewer.viewer()\n\n  # A single post in a stream\n\n  StreamPostView = React.createClass\n\n    propTypes:\n      didLikeComment: React.PropTypes.func.isRequired\n      didCreateComment: React.PropTypes.func.isRequired\n      didLikePost: React.PropTypes.func.isRequired\n      highlighted: React.PropTypes.bool\n      activity: React.PropTypes.object\n\n    # Showing and hiding multiple comments\n    getInitialState: ->\n      showingAllComments: @props.activity.comment_activity_dicts?.length <= 3\n      comments: @props.activity.comment_activity_dicts?[0..2]\n\n    showAllComments: ->\n      @setState showingAllComments: true\n      @setState comments: @props.activity.comment_activity_dicts\n\n    componentWillReceiveProps: (nextProps) ->\n      showingComments = @state.showingAllComments or @props.activity.comment_activity_dicts?.length < 3\n      comments = nextProps.activity.comment_activity_dicts\n      if !showingComments\n        comments = comments[0..2]\n\n      @setState\n        comments: comments\n        showingAllComments: showingComments\n\n    showAll: ->\n      @setState isShowingAllParagraphs: true\n\n    # Returns an array of names of people who've liked this activity, without the viewer.\n    # If Tony, Colin and I have liked this activity, this will return ['Colin', 'Tony'].\n    # This is used for like-links.\n    likeNamesFromActivity: (activity) ->\n      $u.compact $u.map activity.like_dicts, (dict) ->\n        dict.liker_dict.fname unless dict.liker_dict.id == activity.viewing_user.id\n\n    render: ->\n      activity = @props.activity\n      paragraphs = activity.post_text.split(/\\n/)\n\n      d.div {className: if @props.highlighted then 'featured-post'},\n        d.article {},\n          d.img {src: activity.owner.photo_circle_url || activity.owner.initials_url, className: 'avatar'}\n          d.a {href: \"/ns_feed/#{@props.activity.ns_id}/#{@props.activity.activity_key}\"},\n            d.time {}, StreamsUtil.formatDate(activity.when)\n\n          new TruncatedTextView text: activity.post_text, name: activity.owner?.fname\n\n          if activity.activity_key\n            new LikeLink\n              like_dicts: activity.like_dicts\n              didLike: @props.didLikePost\n              like_count: activity.like_count || 0\n              liked: !!activity.liked\n              like_names: @likeNamesFromActivity activity\n          else\n            d.p {className: 'likes'},\n              d.a {}, \"Like\"\n\n          if activity.url\n            d.p {}, activity.url\n\n        for comment_activity in @state.comments\n\n          comment = comment_activity.comment\n\n          d.article {className: 'comment'},\n            d.time {},\n              StreamsUtil.formatDate(comment_activity.when)\n            d.img {className: 'avatar', src: comment.commenter_dict?.photo_circle_url or comment.commenter_dict?.initials_url}\n            d.p {},\n              d.span {className: 'author'}, comment.commenter_dict?.fname\n              d.span {}, \" \"\n              d.span {}, comment.comment_text.split(\"\\n\")[0]\n            for line in comment.comment_text.split(\"\\n\")[1..-1]\n              d.p {}, line\n\n            d.div {},\n              if comment_activity.activity_key != undefined\n                new LikeLink\n                  like_dicts: comment_activity.like_dicts\n                  didLike: @props.didLikeComment.bind(null, activity, comment_activity)\n                  like_count: comment.like_count || 0\n                  liked: comment_activity.liked\n                  like_names: @likeNamesFromActivity comment_activity\n              else\n                d.p {className: 'likes'},\n                  d.a {}, \"Like\"\n              if comment_activity.comment.url\n                d.p {}, comment_activity.url\n\n        unless @state.showingAllComments\n          d.article {className: 'comment'},\n            d.a {href: \"#none\", onClick: @showAllComments}, _(\"Show all comments\")\n\n        d.article {className: 'comment'},\n          d.form {},\n            d.img {className: 'avatar', src: StreamsViewer.photoUrl()}\n            new AutoResizingTextField\n              ref: \"comment-field\"\n              key: \"comment:#{activity.activity_key}:input\"\n              placeholder:  _('Reply...')\n              value: localStorage[\"comment:#{activity.activity_key}\"]\n              didChange: (newValue) =>\n                localStorage[\"comment:#{activity.activity_key}\"] = newValue\n              didSubmit: (result) =>\n                @props.didCreateComment(result)\n                setTimeout =>\n                  @showAllComments()\n                , 100\n","markers":{"markers":{"1":{"id":1,"range":[[0,0],[0,0]],"tailed":false,"reversed":false,"valid":true,"invalidate":"never","persistent":true,"properties":{"type":"selection","editorId":4,"goalBufferRange":null},"deserializer":"Marker"}},"deserializer":"MarkerManager"},"history":{"undoStack":[],"redoStack":[],"deserializer":"History"},"encoding":"utf8","filePath":"/Users/lapier/Sites/streams-ui/public/assets/js/modules/clean/react/streams/streamPostView.coffee","modifiedWhenLastPersisted":false,"digestWhenLastPersisted":"5a0c6ea7a455a31761d2104509f4a772068ea8c6","deserializer":"TextBuffer"}],"deserializer":"Project"},"workspace":{"paneContainer":{"root":{"id":3,"items":[{"id":4,"softTabs":true,"displayBuffer":{"id":5,"softWrapped":false,"editorWidthInChars":null,"scrollTop":7,"scrollLeft":0,"tokenizedBuffer":{"bufferPath":"/Users/lapier/Sites/streams-ui/public/assets/js/modules/clean/react/streams/streamPostView.coffee","invisibles":null,"deserializer":"TokenizedBuffer"},"invisibles":null,"deserializer":"DisplayBuffer"},"deserializer":"TextEditor"}],"activeItemURI":"/Users/lapier/Sites/streams-ui/public/assets/js/modules/clean/react/streams/streamPostView.coffee","focused":true,"deserializer":"Pane"},"activePaneId":3,"deserializer":"PaneContainer","version":1},"fullScreen":false,"packagesWithActiveGrammars":["language-coffee-script","language-javascript","language-hyperlink","language-todo"],"deserializer":"Workspace"},"packageStates":{"fuzzy-finder":{"/Users/lapier/Sites/streams-ui/public/assets/js/modules/clean/react/streams/streamPostView.coffee":1427839012611},"metrics":{"sessionLength":4779364},"tree-view":{"directoryExpansionStates":[{}],"selectedPath":"/Users/lapier/Sites/streams-ui/public/assets/js/modules/clean/react/streams/streamPostView.coffee","hasFocus":false,"attached":true,"scrollLeft":0,"scrollTop":0,"width":200}}}