{"mode":"editor","version":1,"windowDimensions":{"x":0,"y":23,"width":1440,"height":873,"maximized":true},"grammars":{"deserializer":"GrammarRegistry","grammarOverridesByPath":{}},"project":{"paths":["/Users/lapier/Sites/server/metaserver/metaserver/static/coffee/modules/dirty/streams/react"],"buffers":[{"text":"# THIS FILE SHOULD ONLY BE USED FOR THE STREAMS PROTOTYPE\n# AND IS NOT PRODUCTION-READY.\n#\n# CONTACT: elliott@dropbox.com or jeandenis@dropbox.com if you have any questions\n\n# The Streams menu is the left-hand side part of Streams\n# which shows all your streams (and suggested streams)\n# It shows which stream is selected and\n# lets you create a new stream\n\n\"use strict\"\n\ndefine [\n  'external/react'\n  'jquery'\n  'external/underscore'\n  'modules/clean/react/modal'\n  'modules/dirty/streams/actions/view'\n  'modules/dirty/streams/lib/constants'\n  'modules/dirty/streams/lib/model'\n  'modules/dirty/streams/stores/route'\n  'modules/dirty/streams/stores/streams'\n  'modules/dirty/streams/stores/user_settings'\n  'modules/dirty/streams/react/loading_spinner'\n  'modules/dirty/streams/react/settings_modal'\n  'modules/dirty/streams/react/store_mixin'\n  'modules/core/i18n'\n  'modules/dirty/streams/react/search_input'\n  'modules/dirty/streams/lib/dispatcher'\n  'external/immutable'\n], (\n  React\n  $j\n  $u\n  {Modal}\n  ViewActions\n  {ActionTypes, Visibility, Route, NotificationPref}\n  {User}\n  RouteStore\n  StreamsStore\n  UserSettingsStore\n  LoadingSpinner\n  SettingsModal\n  create_store_mixin\n  {_}\n  SearchInput\n  StreamsDispatcher\n  Immutable\n) ->\n\n  d = React.DOM\n  NUMBER_OF_MEMBERS_TO_SHOW_WHEN_COLLAPSED = 3\n\n  HeaderViewController = React.createFactory React.createClass\n\n    displayName: \"HeaderViewController\"\n\n    mixins: [create_store_mixin(StreamsStore, RouteStore, UserSettingsStore)]\n\n    _get_state_from_stores: ->\n      route = RouteStore.route()\n      ns_id = route.ns_id\n      stream_name = do =>\n        switch route.name\n          when Route.CREATE_STREAM\n            _('Create Workspace')\n          when Route.SEARCH\n            _(\"Search\")\n          when Route.HOME\n            _(\"Sonoma\")\n          else\n            setting = StreamsStore.setting(ns_id)\n            if setting?\n              setting.normalized_name()\n            else\n              ''\n\n      state = if ns_id?\n        ns_id: ns_id\n        is_email_backed: StreamsStore.setting(ns_id, 'email_list') or false\n        show_settings_gear: not StreamsStore.setting(ns_id, 'one_on_one_chat', true)\n      else\n        query_context: route.context?.query_context\n        show_settings_gear: false\n        is_email_backed: false\n      return $u.extend state,\n        stream_name: stream_name\n        is_muted: UserSettingsStore.get('in_app_notifications') is 'muted'\n\n    render: ->\n      new HeaderView(@state)\n\n  HeaderView = React.createFactory React.createClass\n    displayName: \"HeaderView\"\n\n    propTypes:\n      show_settings_gear: React.PropTypes.bool.isRequired\n      is_muted: React.PropTypes.bool.isRequired\n      stream_name: React.PropTypes.string.isRequired\n      is_email_backed: React.PropTypes.bool.isRequired\n      # optional\n      ns_id: React.PropTypes.number\n      query_context: React.PropTypes.any\n\n    _toggle_do_not_disturb: (e) ->\n      e.preventDefault()\n      if @props.is_muted\n        UserSettingsStore.set 'in_app_notifications', 'all'\n      else\n        UserSettingsStore.set 'in_app_notifications', 'muted'\n\n    _show_settings: ->\n      Modal.showInstance(\n        new SettingsModal(\n          ns_id: @props.ns_id\n          is_email_backed: @props.is_email_backed\n          stream_name: @props.stream_name\n        )\n      )\n\n    componentDidMount: ->\n      @_dispatch_token = StreamsDispatcher.register(@_new_payload)\n      account_info_div_width = $j(\"#account-header\").width()\n      right = account_info_div_width\n      $j(@refs.mute_button.getDOMNode()).css 'right': right\n\n    componentWillUnmount: ->\n      StreamsDispatcher.unregister(@_dispatch_token)\n\n    _remove_fields_updating: ({ns_id, patch}) ->\n      return unless ns_id is @props.ns_id\n      for key in $u.keys(patch)\n        @state.fields_updating = @state.fields_updating.delete(key)\n      @setState\n        fields_updating: @state.fields_updating\n\n    _new_payload: (payload) ->\n      switch payload.action.type\n        when ActionTypes.SETTINGS_UPDATE, ActionTypes.USER_SETTINGS_UPDATE\n          @_remove_fields_updating(payload.action)\n\n    getInitialState: ->\n      fields_updating: Immutable.Set()\n\n    render: ->\n      d.header {ref: 'header', id: 'header', className: \"main-header\"},\n        d.div {className: 'inner-wrapper', ref: 'header_inner_wrapper'},\n\n          d.section {className: 'left-nav-header'},\n            d.div {className: 'inner-wrapper'},\n              d.div {className: 'dropbox-logo'},\n                d.img {src: \"/static/images/streams/logo.svg\"}\n\n              d.a {className: 'create-stream', href: '/create_stream'},\n                _('New Workspace')\n\n          d.section {className: 'center-feed-header'},\n            d.div {className: 'header-wrapper'},\n              d.h1 {}, @props.stream_name\n\n            d.div {className: 'button-wrapper'},\n              new SearchInput\n                name: \"sonoma-search-input\"\n                initial_search: @props.query_context\n              if @props.show_settings_gear\n                d.a {className: 'header-button settings-toggle', onClick: @_show_settings}\n              # d.a {className: 'header-button files-toggle', onClick: @_toggle_files}\n\n          d.aside {className: ''},\n            d.a {\n              ref: \"mute_button\"\n              onClick: @_toggle_do_not_disturb\n              href: '#'\n              className: React.addons.classSet\n                \"mute-button\": true\n                \"muted\": @props.is_muted\n            },\n              if @props.is_muted\n                _('muted')\n              else\n                _('mute')\n\n  return HeaderViewController\n","markers":{"markers":{"1":{"id":1,"range":[[0,0],[0,0]],"tailed":false,"reversed":false,"valid":true,"invalidate":"never","persistent":true,"properties":{"type":"selection","editorId":4,"goalScreenRange":null,"preserveFolds":true},"deserializer":"Marker"}},"deserializer":"MarkerManager"},"history":{"undoStack":[],"redoStack":[],"deserializer":"History","version":1},"encoding":"utf8","filePath":"/Users/lapier/Sites/server/metaserver/metaserver/static/coffee/modules/dirty/streams/react/header_view.coffee","modifiedWhenLastPersisted":false,"digestWhenLastPersisted":"3f3eb0628768b35f6e4a14f3af077e4ed1b620f6","deserializer":"TextBuffer"},{"text":"# THIS FILE SHOULD ONLY BE USED FOR THE STREAMS PROTOTYPE\n# AND IS NOT PRODUCTION-READY.\n#\n# CONTACT: elliott@dropbox.com or jeandenis@dropbox.com if you have any questions\n\n# Class for showing your Streams feed\n\n\"use strict\"\n\ndefine [\n  'jquery'\n  'external/immutable'\n  'external/react'\n  'external/underscore'\n  'modules/core/i18n'\n  'modules/core/uri'\n  'modules/dirty/streams/models/user'\n  'modules/dirty/streams/models/activity/link_activity'\n  'modules/dirty/streams/models/activity/file_activity'\n  'modules/dirty/streams/actions/view'\n  'modules/dirty/streams/lib/dispatcher'\n  'modules/dirty/streams/react/attachment_view'\n  'modules/dirty/streams/react/stream_text_box'\n  'modules/dirty/streams/lib/check'\n  'modules/dirty/streams/lib/helper'\n  'modules/dirty/streams/lib/constants'\n  'modules/dirty/streams/lib/streams_api'\n  'modules/dirty/streams/react/avatar'\n  'modules/dirty/streams/react/upload_manager'\n  'modules/dirty/streams/react/onboarding'\n  'modules/dirty/streams/react/text_input/stickers'\n  'modules/dirty/streams/react/views/attach_file'\n], (\n  $j\n  Immutable\n  React\n  $u\n  {_}\n  Uri\n  User\n  LinkActivity\n  FileActivity\n  ViewActions\n  StreamsDispatcher\n  AttachmentView\n  StreamTextBox\n  {check}\n  {is_local_stream}\n  {ActionTypes, ActionEventTypes, URL_RE, ATTACHMENT_ERROR_TITLE, FILE_UPLOAD_PATH, STREAM_FEED_ID}\n  StreamsApi\n  AvatarView\n  UploadManager\n  {OnboardingTooltip}\n  {StickersButton}\n  AttachButton\n) ->\n  d = React.DOM\n\n  COMPOSER_ID = \"post-composer\"\n  Attachment =\n    from_url: (url) ->\n      Attachment.from_scrape_result({url, interim: true})\n\n    from_scrape_result: (attachment) ->\n      # title: db_filename(ent.path),\n      # url: url,\n      # icon_src: icon_src,\n      # internal: True,\n      # image_src: image_src,\n      # ns_id: ent.ns_id,\n      # ns_path: ent.path,\n      {url, title, icon_src, image_src} = attachment\n      if not title? or title == ATTACHMENT_ERROR_TITLE\n        title = Uri.parse(url).getAuthority?() ? ''\n      unless icon_src?\n        icon_src = \"/static/images/icons128/page_white_gear.png\"\n      {url, title, icon_src, attachment}\n\n    from_dropbox_chooser: (chooser_file) ->\n      # bytes: 150281\n      # icon: \"https://www.dropbox.com/static/images/icons64/page_white_picture.png\"\n      # link: \"https://www.dropbox.com/s/...\"\n      # name: \"Screenshot 2015-02-26 12.09.04.png\"\n      # thumbnailLink: \"https://api-content.dropbox.com/....\"\n      check chooser_file.link\n      check chooser_file.name\n      check chooser_file.icon\n\n      return Attachment.from_scrape_result\n        url: chooser_file.link\n        title: chooser_file.name\n        icon_src: chooser_file.icon\n        internal: true\n        interim: true\n\n    from_activity: (activity) ->\n      # NOTE: This is wacky\n      # TODO(maxj): Make real interim loading objects instead of faking out attachment data.\n      if activity instanceof LinkActivity\n        return Attachment.from_scrape_result\n          url: activity.url\n          title: activity.title\n          icon_src: activity.icon_src\n      if activity instanceof FileActivity\n        return unless check activity.fq_path\n        return Attachment.from_scrape_result\n          url: activity.fq_path\n          title: activity.name\n          icon_src: \"https://#{Constants.WEBSERVER}/static/images/icons64/#{activity.file_icon}.png\"\n          internal: true\n          ns_id: activity.ns_id\n          ns_path: activity.ns_path\n\n  PostComposerController = React.createFactory React.createClass\n    displayName: \"PostComposerController\"\n\n    propTypes:\n      disable_mentions: React.PropTypes.bool.isRequired\n\n    shouldComponentUpdate: (nextProps, nextState) ->\n      !$u.isEqual(nextProps, @props) or !$u.isEqual(nextState, @state)\n\n    componentDidMount: ->\n      @_dispatch_token = StreamsDispatcher.register(@_new_payload)\n      dropzone = $j(\"##{COMPOSER_ID} .text-input\")\n      dropzone.on 'dragenter', (e) =>\n        @setState dragover: true\n      dropzone.on 'dragleave drop', (e) =>\n        @setState dragover: false\n\n    componentWillUnmount: ->\n      StreamsDispatcher.unregister(@_dispatch_token)\n\n    getInitialState: ->\n      attachments: Immutable.Map()\n      uploads: Immutable.Map()\n      dragover: false\n\n    # File upload callbacks\n    # =====================\n\n    _show_uploader: ->\n      @refs.upload_manager_post.show_upload_dialog()\n\n    _on_file_upload_started: (fq_dest_path, files) ->\n      uploads = @state.uploads\n      for file in files\n        continue unless check file?.id?\n        file.fq_dest_path = fq_dest_path\n        uploads = uploads.set file.id, file\n      @setState {uploads}\n\n    _on_file_upload_progress: (file) ->\n      uploads = @state.uploads\n      return unless uploads.has file.id\n      uploads = uploads.set file.id, file\n      @setState {uploads}\n\n    _on_file_upload_complete: ({id}) ->\n      @_scraping_in_progress or= Immutable.Set()\n      return if @_scraping_in_progress.contains id\n      return unless @state.uploads.has id\n      @_scraping_in_progress = @_scraping_in_progress.add id\n\n      file = @state.uploads.get(id)\n      fq_path = file.fq_dest_path + '/' + file.name\n      StreamsApi.retry {}, ->\n        StreamsApi.fetch_shared_link {fq_path}\n      .then ({payload}) =>\n        if check payload.link?, \"No shared link for this file\"\n          StreamsApi.fetch_link_preview {url: payload.link}\n      .then ({payload}) =>\n        # Ignore if we no longer care about this upload.\n        return unless @state.uploads.has id\n\n        # Save the attachment.\n        attachment = Attachment.from_scrape_result(payload.data)\n        @_set_attachments [attachment]\n        @_scraping_in_progress = @_scraping_in_progress.delete id\n\n    # Other callbacks\n    # ===============\n\n    _dropbox_chose: (files) ->\n      attachments = (Attachment.from_dropbox_chooser(file) for file in files)\n      @_set_attachments attachments\n\n      # Fetch a proper preview for the attachments.\n      for {url} in attachments\n        StreamsApi.fetch_link_preview {url}\n        .then ({payload}) =>\n          # Ignore if we no longer care about this attachment.\n          return unless @state.attachments.has payload.url\n\n          # Save the attachment.\n          attachment = Attachment.from_scrape_result(payload.data)\n          @_set_attachments [attachment]\n\n    _handle_url: (url) ->\n      # Add url to attachments\n      @_set_attachments [Attachment.from_url(url)]\n\n      # Fetch preview\n      StreamsApi.fetch_link_preview {url}\n      .then ({payload}) =>\n        # Ignore if we're no longer loading this url\n        return unless @state.attachments.has payload?.data?.url\n        # Save attachment\n        attachment = Attachment.from_scrape_result(payload.data)\n        @_set_attachments [attachment]\n\n    _handle_submit: (post_text) ->\n      attachments = (a.attachment for a in @_get_attachments())\n      ViewActions.create_post {post_text, attachments}\n      @_clear()\n      $u.defer @_focus\n\n    _discuss_link: (link_activity) ->\n      # Create an interim attachment object\n      attachment = Attachment.from_activity link_activity\n      return unless check attachment?\n      @_set_attachments [attachment]\n\n    _discuss_file: (file_activity) ->\n      # Make sure we have a previewable activitiy\n      fq_path = file_activity.fq_path\n      return unless check fq_path?\n\n      # Create an interim attachment object\n      temp_attach = Attachment.from_activity file_activity\n      return unless check temp_attach?\n      @_set_attachments [temp_attach]\n\n      # Fetch a shared link and preview dict for the file\n      StreamsApi.retry {}, ->\n        StreamsApi.fetch_shared_link {fq_path}\n      .then ({payload}) =>\n        if check payload.link?, \"No shared link for this file\"\n          StreamsApi.fetch_link_preview {url: payload.link}\n      .then ({payload}) =>\n        # Ignore if we no longer care about this attachment.\n        return unless @state.attachments.contains temp_attach\n\n        # Replace temp_attach with the new attachment data.\n        attachment = Attachment.from_scrape_result(payload.data)\n        attachments = @state.attachments\n        attachments = attachments.delete temp_attach.url\n        attachments = attachments.set attachment.url, attachment\n        @setState {attachments}\n\n    _new_payload: ({action}) ->\n      switch action.type\n        when ActionEventTypes.SharedFolder.DISCUSS\n          {activity} = action\n          if activity instanceof LinkActivity\n            @_discuss_link activity\n          if activity instanceof FileActivity\n            @_discuss_file activity\n\n        when ActionTypes.UPDATE_ROUTE\n          # don't clear post input when creating a local stream\n          if action.prev_route?.ns_id? and action.route?.ns_id?\n            if is_local_stream(action.prev_route.ns_id) and not is_local_stream(action.route.ns_id)\n              return\n\n          @_clear()\n\n    _handle_remove: (url) ->\n      @setState\n        attachments: @state.attachments.delete url\n\n    # Helper methods\n    # ==============\n\n    _set_attachments: (new_attachments) ->\n      attachments = @state.attachments\n      for attachment in new_attachments\n        attachments = attachments.set attachment.url, attachment\n      @setState {attachments}\n\n    _get_uploads: ->\n      @state.uploads.toArray()\n\n    _get_attachments: ->\n      @state.attachments.toArray()\n\n    _focus: ->\n      @refs.post_composer.focus()\n\n    _clear: ->\n      @setState @getInitialState()\n      @refs.post_composer.clear()\n\n    render: ->\n      d.section null,\n        new PostComposer\n          ref: \"post_composer\"\n          key: \"post_composer_view\"\n          dom_id: COMPOSER_ID\n          ns_id: @props.ns_id\n          disable_mentions: @props.disable_mentions\n          attachments: @_get_attachments()\n          uploads: @_get_uploads()\n          stream_name: @props.stream_name\n          dragover: @state.dragover\n          on_dropbox_chose: @_dropbox_chose\n          on_upload: @_show_uploader\n          on_url: @_handle_url\n          on_submit: @_handle_submit\n          on_remove: @_handle_remove\n\n        unless is_local_stream(@props.ns_id)\n          new UploadManager\n            ref: 'upload_manager_stream'\n            key: \"stream_upload_manager\"\n            ns_id: @props.ns_id\n            ns_path: '/' + FILE_UPLOAD_PATH\n            drop_target_id: STREAM_FEED_ID\n            on_file_upload_started: @_on_file_upload_started\n            on_file_upload_progress: @_on_file_upload_progress\n            on_file_upload_complete: @_on_file_upload_complete\n\n          new UploadManager\n            ref: 'upload_manager_post'\n            key: \"post_composer_upload_manager\"\n            ns_id: @props.ns_id\n            ns_path: '/' + FILE_UPLOAD_PATH\n            drop_target_id: COMPOSER_ID\n            on_file_upload_started: @_on_file_upload_started\n            on_file_upload_progress: @_on_file_upload_progress\n            on_file_upload_complete: @_on_file_upload_complete\n\n  PostComposer = React.createFactory React.createClass\n    displayName: \"PostComposer\"\n\n    propTypes:\n      disable_mentions: React.PropTypes.bool.isRequired\n\n    componentDidMount: ->\n      @_handle_resize()\n      window.addEventListener 'resize', @_handle_resize\n\n    componentWillUnmount: ->\n      window.removeEventListener 'resize', @_handle_resize\n\n    getInitialState: ->\n      in_focus: false\n\n    content: ->\n      @refs.stream_text_box.content()\n\n    focus: ->\n      @refs.stream_text_box.focus()\n\n    clear: ->\n      @refs.stream_text_box.clear()\n\n    _handle_resize: ->\n      composerWrapper = @refs.composer_wrapper.getDOMNode()\n      computedWidth = $j(composerWrapper).parents('main').innerWidth()\n      composerWrapper.style.width = \"#{computedWidth}px\"\n\n    _on_focus: ->\n      @setState in_focus: true\n\n    _on_blur: ->\n      @setState in_focus: false\n\n    _on_paste: (e) ->\n      # Make sure that the element that was pasted into is a child of the composer.\n      pasted_in_composer = @getDOMNode() in $j(e.target).parents()\n      return unless check pasted_in_composer, \"Got paste callback from non-composer element?!\"\n\n      # Get pasted data.\n      if window.clipboardData and window.clipboardData.getData\n        # IE\n        pasted_text = window.clipboardData.getData('Text')\n      else\n        # other browsers\n        pasted_text = e.clipboardData?.getData?('text/plain')\n      url = $u.last pasted_text.match URL_RE\n      if url?\n        @props.on_url(url)\n\n    _handle_sticker: (sticker_set, sticker_id, img_src) ->\n      ViewActions.create_post post_text: \"::#{sticker_set}:#{sticker_id}::\"\n\n    render: ->\n      placeholder = _('Say something\\u2026').format(stream_name: @props.stream_name)\n\n      drag_class = if @props.dragover then ' dragover' else ''\n      classes = if @state.in_focus then ' open' else ''\n\n      d.section {className: \"composer-wrapper#{drag_class}\", id: @props.dom_id},\n        d.nav {}\n        d.div {className: 'center-composer', ref: 'composer_wrapper'},\n          new AvatarView\n            actor: User.viewer\n            tooltip_position: 'right'\n            show_presence: false\n            has_timer: false\n          d.section {className: \"composer#{classes}\", ref: 'composer'},\n            new OnboardingTooltip ns_id: @props.ns_id\n\n            new StreamTextBox\n              key: 'post_composer_stream_text_box'\n              ref: 'stream_text_box'\n              allow_empty: @props.attachments?.length > 0\n              placeholder: placeholder\n              disable_mentions: @props.disable_mentions\n              did_submit: @props.on_submit\n              on_paste: @_on_paste\n              requires_modifier_key_to_submit: false\n              on_focus: @_on_focus\n              on_blur: @_on_blur\n              on_key_up: @props.on_key_up\n\n            d.div className: \"buttons-wrapper\",\n              new StickersButton\n                ref: \"stickerbutton\"\n                onStickerSelected: @_handle_sticker\n              new AttachButton\n                on_dropbox_chose: @props.on_dropbox_chose\n                on_upload: @props.on_upload\n\n          new AttachmentsWrapper\n            in_focus: @state.in_focus\n            uploads: @props.uploads\n            attachments: @props.attachments\n            on_remove: @props.on_remove\n\n          d.div {className: 'shift-enter-message'}, \"shift-enter for new line\"\n        d.aside {}\n\n  AttachmentsWrapper = React.createClass\n    render: ->\n      d.div {},\n        d.section {className: 'attachments-wrapper'},\n          d.ul {className: 'attachments'},\n            if @props.uploads.length > 0\n              for {id, name, percent} in @props.uploads\n                d.li {className: \"file-progress #{if percent is 100 then 'finished' else ''}\", key: \"uploadfile:#{id}\"},\n                  d.span {className: 'progress', style: {width: \"#{percent}%\"}}\n\n          if @props.attachments.length\n            d.section {className: \"attachments-preview\"},\n              new AttachmentView\n                attachments: @props.attachments\n                editable: true\n                on_remove: @props.on_remove\n\n  return PostComposerController\n","markers":{"markers":{"1":{"id":1,"range":[[0,0],[0,0]],"tailed":false,"reversed":false,"valid":true,"invalidate":"never","persistent":true,"properties":{"type":"selection","editorId":14,"goalScreenRange":null},"deserializer":"Marker"}},"deserializer":"MarkerManager"},"history":{"undoStack":[],"redoStack":[],"deserializer":"History","version":1},"encoding":"utf8","filePath":"/Users/lapier/Sites/server/metaserver/metaserver/static/coffee/modules/dirty/streams/react/post_composer.coffee","modifiedWhenLastPersisted":false,"digestWhenLastPersisted":"1ff5c58d73c70476c5bb2881d7e2e2e92f4c0b3b","deserializer":"TextBuffer"}],"deserializer":"Project"},"workspace":{"paneContainer":{"root":{"id":3,"items":[{"id":4,"softTabs":true,"displayBuffer":{"id":5,"softWrapped":false,"editorWidthInChars":null,"scrollTop":0,"scrollLeft":0,"tokenizedBuffer":{"bufferPath":"/Users/lapier/Sites/server/metaserver/metaserver/static/coffee/modules/dirty/streams/react/header_view.coffee","invisibles":null,"deserializer":"TokenizedBuffer"},"invisibles":null,"deserializer":"DisplayBuffer"},"deserializer":"TextEditor"},{"id":14,"softTabs":true,"displayBuffer":{"id":15,"softWrapped":false,"editorWidthInChars":null,"scrollTop":0,"scrollLeft":0,"tokenizedBuffer":{"bufferPath":"/Users/lapier/Sites/server/metaserver/metaserver/static/coffee/modules/dirty/streams/react/post_composer.coffee","invisibles":null,"deserializer":"TokenizedBuffer"},"invisibles":null,"deserializer":"DisplayBuffer"},"deserializer":"TextEditor"}],"activeItemURI":"/Users/lapier/Sites/server/metaserver/metaserver/static/coffee/modules/dirty/streams/react/post_composer.coffee","focused":true,"deserializer":"Pane"},"activePaneId":3,"deserializer":"PaneContainer","version":1},"fullScreen":false,"packagesWithActiveGrammars":["language-coffee-script","language-hyperlink","language-todo"],"deserializer":"Workspace"},"packageStates":{"fuzzy-finder":{"/Users/lapier/Sites/server/metaserver/metaserver/static/coffee/modules/dirty/streams/react/header_view.coffee":1430432130675,"/Users/lapier/Sites/server/metaserver/metaserver/static/coffee/modules/dirty/streams/react/post_composer.coffee":1430432131710},"metrics":{"sessionLength":1957},"tree-view":{"directoryExpansionStates":{"/Users/lapier/Sites/server/metaserver/metaserver/static/coffee/modules/dirty/streams/react":{"isExpanded":true,"entries":{"__tests__":{"isExpanded":false,"entries":{}},"feed":{"isExpanded":false,"entries":{}},"mixins":{"isExpanded":false,"entries":{}},"text_input":{"isExpanded":false,"entries":{}},"views":{"isExpanded":false,"entries":{}}}}},"selectedPath":"/Users/lapier/Sites/server/metaserver/metaserver/static/coffee/modules/dirty/streams/react/post_composer.coffee","hasFocus":false,"attached":true,"scrollLeft":0,"scrollTop":0,"width":200}}}